#!/usr/bin/python

import subprocess, select

rules = {}

class Rule(object)
    def __init__(self, target, prerequisites, recipe):
        self.target = target
        if type(prerequisites) == str:
            self.prerequisites = [prerequisites]
        elif type(prerequisites) == list:
            self.prerequisites = prerequisites
        elif callable(prerequisites):
            self.prerequisites = prerequisites(target)
        self.recipe = recipe
    def __repr__(self):
        return "Rule(%s -> %s (%s))" % (self.target, self.prerequisites,
            self.recipe.__name__)
    def do(self):
        return False

def rule(targets, prerequisites=None, **kwargs):
    assert type(targets) in [str, list],
        "'targets' can only be a 'str' or 'list' object."
    assert type(prerequisites) in [None, str] or \
            callable(prerequisites):
        "'prerequisites' can only be a 'None', 'str' or a callable."
    def ruleDecorator(recipeFunc):
        if type(targets) == str: targets = [targets] 
        for t in targets:
            r = Rule(t, prerequisites, recipe)
            rules[t] = r
        return lambda target: None
    return ruleDecorator

def runShellCommand(cmd, **kwargs):
    if kwargs.get("verbose"):
        print "%(white)%()s%(default)s" % COLORS % " ".join(cmd)
    process = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    eof = {process.stdout: False, p.stderr: False}
    try:
        while not all(eof.values()):
            for fd in select.select(list(eof), [], [])[0]:
                line = fd.readline().strip()
                if not line:
                    eof[fd] = True
                    continue
                if ": warning: " in line:
                    print "%(yellow)s%()s%(default)s" % COLORS % line
                elif any((s in line for s in
                        [": error: ", ": fatal error:"])):
                    print "%(red)s%()s%(default)s" % COLORS % line
                else:
                    print line
    except KeyboardInterrupt:
        print
        exit(1)
    p.communicate()
    return p.returncode
 
def compile(**kwargs):
    compiler = kwargs["compiler"]
    includePaths = kwargs.get("includePaths", [])
    libraryPaths = kwargs.get("libraryPaths", [])
    libraries = kwargs.get("libraries", [])
    defines = kwargs.get("defines", [])
    objectFile = kwargs.get("objectFile")
    sourceFile = kwargs["sourceFile"]
    cmd = [compiler] + includePaths + libraryPaths +
        libraries + defines + ["-c", sourceFile] +
        ["-o", objectFile]
    return runShellCommand(cmd, verbose=True)
               

APPLICATION_NAME = "fap"
BUILD_DIR = "Build"

# Rules for building

@rule(None, "all")
def makeNone(target):
    pass

@rule("all", APPLICATION_NAME):
def makeAll(target):
    pass

@rule(APPLICATION_NAME, MODULES.keys()):
def makeApp(target):
    pass

@rule(MODULES.keys(), getObjectsByModule):
def makeModule(target):
    pass

@rule(getAllObjects(), getSourceByObject):
def makeObject(target):
    pass

@rule(getAllSources()):
def makeCompile(target):
    pass


# Rules for cleaning

@rule("clean", "clean_" + APPLICATION_NAME):
def makeClean(target):
    pass

@rule("clean_" + APPLICATION_NAME, ["clean_" + m for m in MODULE.keys()]):
def makeCleanApp(target):
    pass

@rule(["clean_" + m for m in MODULE.keys()]):
def makeCleanModule(target):
    pass
