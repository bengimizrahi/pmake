#!/usr/bin/python

# Author: Bengi Mizrahi
# Date: 05.06.2012

import sys
import imp
import os
import re
import shutil
import string
import datetime

COLORS = { "blue": "\033[1;34m", "default": "\x1B[m", "yellow": "\033[1;33m",
    "magenda": "\033[1;31m", "white": "\033[1;37m", "green": "\033[1;32m",
    "red": "\033[1;31m",
}
NOCOLORS = dict(map(lambda c: (c, ""), COLORS.iterkeys()))

class File:
    def __init__(self, filename, directory, extension, filePath):
        self.filename = filename
        self.canonical = os.path.splitext(filename)[0]
        self.directory = directory
        self.extension = extension
        self.filePath = filePath
    def dependFilePath(self):
        return os.path.join(self.directory, "%s.d" % self.canonical)
    def objectFilePath(self):
        return os.path.join(self.directory, "%s.o" % self.canonical)
    def __repr__(self):
        return "`%s`/%s .%s" % (self.directory, self.canonical,
            self.extension)

def scanSourceFiles(module):
    results = []
    query = None
    sourceFiles = None
    if module.get("sourcefilter"):
        query = module["sourcefilter"].replace("?", "absf")
    if module.get("sourcefiles"):
        sourceFiles = module["sourcefiles"]
    for rootdir, subdirs, files in os.walk(module["directory"]):
        for f in files:
            absf = os.path.join(rootdir, f)
            if query and not eval(query):
                continue
            if sourceFiles and not any(map(lambda f: f in absf,
                    sourceFiles)):
                continue
            el = filter(lambda e: f.endswith(e), extensions)
            if el:
                ext = el.pop()
                results.append(File(f, rootdir, ext,
                    os.path.join(rootdir, f)))
    return results


if __name__ == "__main__":

    # Get current date/time
    now = datetime.datetime.now()

    # Get the target
    target = "all"
    if len(sys.argv) == 2:
        target = sys.argv[1]

    # Import makefile.py
    try:
        with file("Makefile.py") as f:
            exec(f.read())
    except IOError:
        print "Error: No such file: Makefile.py"
        exit(1)
    
    # Determine if colorful output is desired
    if not COLOR:
        COLORS = NOCOLORS

    # Process COMPILER
    compiler = {}
    for cmpl, exts in COMPILER.iteritems():
        for ext in exts:
            compiler[ext] = cmpl 

    # If BUILD_DIR does not exist, create it.
    if not os.path.exists(BUILD_DIR):
        os.makedirs(BUILD_DIR)

    # Check if desired configuration exists
    activeConfiguration = CONFIGURATIONS.get(ACTIVE_CONFIGURATION)
    if not activeConfiguration:
        print "Error: ACTIVE_CONFIGURATION(%s) not found in CONFIGURATIONS(%s)" % (
            activeConfiguration,
            ", ".join(CONFIGURATIONS.keys()))
        exit(1)

    # Check if desired configuration is valid
    requiredConfigurationParameters = ["buildsubdir"]
    if any(map(lambda p: activeConfiguration.get(p) is None,
            requiredConfigurationParameters)):
        print "Error: One or more required parameters are missing. The " \
              "following parameters are required: %s." % \
              ", ".join(requiredConfigurationParameters)
        exit(1)

    # Get the active configuration build sub directory
    acBuildDirectory = os.path.join(BUILD_DIR,
        activeConfiguration["buildsubdir"])

    # Create the active configuration build sub directory
    if not os.path.exists(acBuildDirectory):
        os.makedirs(acBuildDirectory)

    # Check if desired modules exists
    notFound = filter(lambda m: not m in MODULES.keys(), ACTIVE_MODULES)
    if notFound:
        print "Error: No module(s) named %s found in MODULES." % notFound 
        exit(1)
    activeModules = dict(filter(lambda m: m[0] in ACTIVE_MODULES,
        MODULES.iteritems()))

    # Clean the active configuration build sub directory
    # if target == "clean"
    if target == "clean":
        print "%sClean %s%s" % (COLORS["blue"],
            acBuildDirectory, COLORS["default"])
        try:
            shutil.rmtree(acBuildDirectory)
        except OSError, e:
            print e
            pass
        for name, module in activeModules.iteritems():
            if module.get("cleancmd"):
                system("cd %s" % module["directory"])
                system(module["cleancmd"])
                system("cd -") 
        exit(0)

    # Build each active module
    archiveFiles = list()
    atLeastOneArchiveFileCreated = False
    for name, module in activeModules.iteritems():

        # Setup default module parameters
        if not module.get("directory"):
            module["directory"] = name
        if not module.get("incpaths"):
            module["incpaths"] = []
        if not module.get("defines"):
            module["defines"] = []

        # If extbuildcmd exists, build with the external tool
        if module.get("extbuildcmd"):
            print "%s%s%s" % (COLORS["yellow"], module["extbuildcmd"],
                COLORS["default"])
            print os.path.abspath(os.curdir)
            os.chdir(module["directory"])
            os.system(module["extbuildcmd"])
            os.chdir("..")
            continue

        # Create module build directory
        moduleBuildDirectory = os.path.join(acBuildDirectory,
            module["directory"])
        if not os.path.exists(moduleBuildDirectory):
            os.makedirs(moduleBuildDirectory)

        # List all source files
        extensions = reduce(lambda a, b: a + b, COMPILER.values())
        sourceFiles = scanSourceFiles(module)

        # Compile each source file
        def createObjectFile():
            cmd = " ".join((
                compiler[sourceExtension],
                '-DBUILD_USER_NAME="%s"' % BUILD_USER["name"],
                '-DBUILD_USER_EMAIL="%s"' % BUILD_USER["email"],
                '-DBUILD_DATE="%s"' % now,
                " ".join(activeConfiguration["flags"]),
                " ".join(module["defines"]),
                " ".join(("-I%s" % i for i in 
                    [os.path.join(
                        module["directory"],
                        module.get("includedir", ".")
                    )] + module["incpaths"])),
                "-c",
                sourceFilePath,
                "-o",
                objectFilePath))
            print "%sCompile:%s %s%s%s" % (
                COLORS["blue"], COLORS["default"],
                COLORS["yellow"], sourceFile.filePath, COLORS["default"])
            print "%s%s%s" % (COLORS["white"], cmd, COLORS["default"])
            if not os.path.exists(os.path.join(acBuildDirectory, sourceDirectory)):
                os.makedirs(os.path.join(acBuildDirectory, sourceDirectory))
            rt = os.system(cmd)
            if rt:
                print "%sError:%smake.py exited with error code %d" % (
                    COLORS["red"], COLORS["default"], rt)
                exit(rt)
        def createDependencyFile():
            cmd = " ".join((
                compiler[sourceExtension],
                "-MM",
                " ".join(activeConfiguration["flags"]),
                " ".join(module["defines"]),
                " ".join(("-I%s" % i for i in 
                    [os.path.join(
                        module["directory"],
                        module.get("includedir", ".")
                    )] + module["incpaths"])),
                sourceFilePath,
                "-o",
                dependFilePath))
            rt = os.system(cmd)
            if rt:
                print "%sError:%smake.py exited with error code %d" % (
                    COLORS["red"], COLORS["default"], rt)
                exit(rt)
        def modifyTime(filename):
            return os.path.getmtime(filename)
        def anyDirtyFileInDependencyFile():
            try:
                with file(dependFilePath) as depend:
                    trans = string.maketrans('\\\n', '  ')
                    t1, _, t2 = (t.strip() for t in
                        depend.read().translate(trans).strip().partition(
                            ":"))
                    obj, deps = os.path.join(acBuildDirectory,
                        sourceDirectory, t1), t2.split()
                    dirtyFiles = set(filter(
                        lambda d: modifyTime(d) > modifyTime(obj), deps))
                    if dirtyFiles:
                        print "%sDep: %s%s%s%s -> %s" % (
                            COLORS["blue"], COLORS["default"],
                            COLORS["yellow"], obj, COLORS["default"],
                             ", ".join(dirtyFiles))
                    return bool(dirtyFiles)
            except IOError:
                print "File %s not found" % sourceFile.dependFilePath()
                return True
        (NO_OBJECT_FILE_FOUND,
         DEPENDENCIES_ARE_RECENT_THAN_OBJECT_FILE,
         OBJECT_FILE_IS_THE_MOST_RECENT) = range(3)
        atLeastOneObjectFileCreated = False
        for sourceFile in sourceFiles:
            sourceFilePath = sourceFile.filePath
            objectFilePath = os.path.join(acBuildDirectory,
                sourceFile.objectFilePath())
            dependFilePath = os.path.join(acBuildDirectory,
                sourceFile.dependFilePath())
            sourceDirectory = sourceFile.directory
            sourceExtension = sourceFile.extension
            if not os.path.exists(objectFilePath):
                condition = NO_OBJECT_FILE_FOUND
            elif anyDirtyFileInDependencyFile():
                condition = DEPENDENCIES_ARE_RECENT_THAN_OBJECT_FILE
            else:
                condition = OBJECT_FILE_IS_THE_MOST_RECENT
            if condition != OBJECT_FILE_IS_THE_MOST_RECENT:
                createObjectFile()
                atLeastOneObjectFileCreated = True
                createDependencyFile()

        # Create library for the module
        moduleObjectFiles = map(lambda s: os.path.join(acBuildDirectory, s.objectFilePath()),
            sourceFiles)
        libFilePath = os.path.join(acBuildDirectory,
            MODULES[name]["directory"],
            "lib%s.a" % name)
        archiveFiles.append(libFilePath)
        if not os.path.exists(libFilePath) or any(
                map(lambda o: modifyTime(libFilePath) < modifyTime(o),
                    moduleObjectFiles)):
            print "%sArchive:%s %s%s%s" % (
                COLORS["magenda"], COLORS["default"],
                COLORS["yellow"], libFilePath, COLORS["default"])
            objects = " ".join(moduleObjectFiles)
            cmd = " ".join((
                AR,
                "cr",
                libFilePath,
                objects
            ))
            print "%s%s%s" % (COLORS["white"], cmd, COLORS["default"])
            rt = os.system(cmd)
            if rt:
                print "%sError:make.py exited with error code %d%s" % (
                    COLORS["red"], rt, COLORS["default"])
                exit(rt)
            atLeastOneArchiveFileCreated = True

    # Link all object files
    if not "APPLICATION_NAME" in vars():
        exit(0)
    targetFilePath = os.path.join(acBuildDirectory,
        APPLICATION_NAME)
    if not os.path.exists(targetFilePath) or \
            atLeastOneArchiveFileCreated or \
            any(map(lambda a: modifyTime(targetFilePath) < modifyTime(a),
                archiveFiles)):
        print "%sLink:%s %s%s%s" % (COLORS["green"], COLORS["default"],
            COLORS["yellow"], targetFilePath, COLORS["default"])
        allLibraryPaths = LIBRARY_PATHS + map(
            lambda n: os.path.join(acBuildDirectory,
                MODULES[n]["directory"]), ACTIVE_MODULES)
        allLibraries = LIBRARIES + ACTIVE_MODULES
        cmd = " ".join((
            LINKER,
            " ".join(LDFLAGS),
            " ".join(("-L%s" % d for d in allLibraryPaths)),
            " ".join(("-l%s" % l for l in allLibraries)),
            "-o",
            targetFilePath
        ))
        print "%s%s%s" % (COLORS["white"], cmd, COLORS["default"])
        rt = os.system(cmd)
        if rt:
            print "%sError:%smake.py exited with error code %d" % (
                COLORS["red"], COLORS["default"], rt)
            exit(rt)
        shutil.copy(targetFilePath, APPLICATION_NAME)
