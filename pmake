#!/usr/bin/python

# -------------------- pmake --------------------

import subprocess, select
import os, sys

COLORS = {"blue": "\033[1;34m", "default": "\x1B[m", "yellow": "\033[1;33m",
    "magenda": "\033[1;31m", "white": "\033[1;37m", "green": "\033[1;32m",
    "red": "\033[1;31m",
}
NOCOLORS = dict(map(lambda c: (c, ""), COLORS))

DEFAULT_COMPILER = "gcc"
DEFAULT_ARCHIVER = "ar"
DEFAULT_LINKER = "gcc"

rules = {}

class Rule(object):
    def __init__(self, target, prerequisites, recipe, args, kwargs):
        self.target = target
        self.prerequisites = prerequisites
        self.recipe = recipe
        self.args = args
        self.kwargs = kwargs
    def __repr__(self):
        return "Rule(%s: %s | %s(%s,%s))" % (self.target,
                self.prerequisites,
            self.recipe.__name__, self.args,
            self.kwargs)
    def make(self):
        shouldRunRecipe = False
        if type(self.prerequisites) == list:
            prerequisites = self.prerequisites
        if type(self.prerequisites) == str:
            prerequisites = [self.prerequisites]
        elif callable(self.prerequisites):
            prerequisites = self.prerequisites(target, *args, **kwargs)
        for p in prerequisites:
            if p in rules:
                if rules[p].make():
                    shouldRunRecipe = True
            else:
                if os.utime(self.target) < os.utime(p):
                    shouldRunRecipe = True
        if shouldRunRecipe:
            rt = self.recipe(target, *args, **kwargs)
            if (rt is None) or (rt is 0):
                return True
            else:
                exit(rt)
        else:
            return False


def rule(targets, prerequisites=None, *args, **kwargs):
    assert type(targets) in [str, list], \
        "'targets' can only be a 'str' or 'list' object."
    assert type(prerequisites) in [None, str] or \
            callable(prerequisites), \
        "'prerequisites' can only be a 'None', 'str' or a callable."
    def ruleDecorator(recipe):
        if type(targets) == str: targets = [targets] 
        for t in targets:
            r = Rule(t, prerequisites, recipe, args, kwargs)
            rules[t] = r
        return lambda target: None
    return ruleDecorator

def cache(f):
    results = {}
    def newf(arg):
        return results.setdefault(arg, f(arg))
    return newf

def validate(require, defaults):
    def validateDecorator(f):
        def newf(**kwargs):
            missingRequiredArgs = filter(
                lambda r: not r in kwargs, require)
            if missingRequiredArgs:
                print "Error: function %s requires: %s" % \
                    ", ".join(missingRequiredArgs)
                return False
            missingOptionalArgs = filter(
                lambda o: not o in kwargs, defaults)
            for o in missingOptionalArgs:
                kwargs[o] = defaults[o]
            return f(**kwargs)
        return newf
    return validateDecorator

def runShellCommand(cmd, **kwargs):
    if kwargs.get("verbose"):
        print "%(white)%()s%(default)s" % COLORS % " ".join(cmd)
    process = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    eof = {process.stdout: False, process.stderr: False}
    while not all(eof.values()):
        for fd in select.select(list(eof), [], [])[0]:
            line = fd.readline().strip()
            if not line:
                eof[fd] = True
                continue
            if ": warning: " in line:
                print "%(yellow)s%()s%(default)s" % COLORS % line
            elif any((s in line for s in
                    [": error: ", ": fatal error:"])):
                print "%(red)s%()s%(default)s" % COLORS % line
            else:
                print line
    process.communicate()
    return process.returncode and True or False

@validate(
    require=["depend", "source"],
    defaults={
        "compiler": DEFAULT_COMPILER,
        "includePaths": [],
        "defines": [],
    })
def makeDepend(**kwargs):
    compiler = kwargs["compiler"]
    includePaths = kwargs["includePaths"]
    dependFile = kwargs["depend"]
    if not "-I." in includePaths:
        includePaths.append("-I.")
    defines = kwargs["defines"]
    sourceFile = kwargs["source"]
    cmd = [compiler, "-MM"] + includePaths + \
        defines + [sourceFile] + ["-o", dependFile]
    return runShellCommand(cmd, verbose=False)

@validate(
    require=["object", "source"],
    defaults={
        "compiler": DEFAULT_COMPILER,
        "includePaths": [],
        "defines": [],
    })
def compilee(**kwargs):
    compiler = kwargs["compiler"]
    includePaths = kwargs["includePaths"]
    if not "-I." in includePaths:
        includePaths.append("-I.")
    defines = kwargs["defines"]
    objectFile = kwargs["object"]
    sourceFile = kwargs["source"]
    cmd = [compiler] + includePaths + \
        defines + ["-c", sourceFile] + ["-o", objectFile]
    return runShellCommand(cmd, verbose=True)

@validate(
    require=["archive", "objects"],
    defaults={
        "linker": DEFAULT_LINKER,
    })
def link(**kwargs):
    linker = kwargs["linker"]
    archiveFile = kwargs["archive"]
    objectFiles = kwargs["objects"]
    cmd = [linker, "cr", archiveFile] + objectFiles
    return runShellCommand(cmd, verbose=True)

def getRootDirectoryPath():
    return os.getcwd()

# ----------------- Makefile.py -----------------

enableColor = True
compiler = "g++"
linker = "g++"
ar = "ar"
commonCflags = ["-O3", "-Wall",]
ldFlags = ["-Xlinker", "--start-group"]
buildDir = ".build"
activeConfiguration = "debug"
configurations = {
    "debug" : {
        "flags" : commonCflags + ["-g"],
        "buildsubdir" : "Debug",
    },
    "release" : {
        "flags" : commonCflags,
        "buildsubdir" : "Release",
    },
}
libraryPaths = []
libraries = []
modules = {
    "app" : {
        "incpaths" : ["rrm"],
        "defines" : [],
    },
    "rrm" : {
        "incpaths" : [],
        "defines" : [],
    },
}
applicationName = "fap." + activeConfiguration

def getBuildDirectoryPath():
    return getRootDirectory() + buildDir

@cache
def getBuildConfigurationDirectoryPath(configName):
    return getBuildDirectoryPath() + \
        configurations[configName]["buildsubdir"]

def getObjectsOfModule(module):
    pass

def getSourcesOfModule(module):
    pass

def getDependsOfSource(source):
    dependPath = os.path.join(
        getBuildConfigurationDirectoryPath(activeConfiguration),
        os.path.splitext(source)[0] + ".d")
    if not os.path.exists(dependPath):
        return []
    with file(dependPath) as f:
        <continue>    

# Rules for building
@rule("all", applicationName)
def makeAll(target):
    pass

@rule(applicationName, list(modules))
def makeApp(target):
    pass

@rule(list(modules), getObjectsOfModule)
def makeModule(target):
    archive = os.path.join(
        getBuildConfigurationDirectoryPath(activeConfiguration),
        target, "lib%s.a" % target)
    link(linker=linker,
        objects=getObjectsOfModule(target)
        archive=archive)

for m in modules:
    @rule(getObjectsOfModule(m), getDependsOfObject, m)
    def makeObject(target, m):
        prefix = os.path.splitext(target)[0]
        source = prefix + ".c"
        compilee(compiler=compiler,
            includePaths=m["incpaths"],
            source=source,
            object=target)
        depend = prefix + ".d"
        makeDepend(compiler=compiler,
            includePaths=m["incpaths"],
            source=source,
            depend=depend)

# Rules for cleaning
@rule("clean", "clean_" + applicationName)
def makeClean(target):
    pass

@rule("clean_" + applicationName,
    ["clean_" + m for m in list(modules)])
def makeCleanApp(target):
    pass

@rule(["clean_" + m for m in list(modules)])
def makeCleanModule(target):
    pass

# ----------------- pmake -----------------------

if __name__ == "__main__":

    # Determine if colorful output is desired
    if not enableColor:
        COLORS = NOCOLORS

    # Get the target
    target = "all"
    if len(sys.argv) == 2:
        target = sys.argv[1]
    
    # Make the target
    if not rules.get(target):
        print "Error: target '%s' not found" % target
        exit(1)
    rules[target].make()
