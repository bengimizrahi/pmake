#!/usr/bin/python

# -------------------- pmake --------------------

import subprocess, select
import os, sys
from functools import wraps
from collections import namedtuple
import pprint
import inspect


ENABLE_COLOR = True
DEBUG_LOGS = False
SHOW_DIRTY_DEPENDENCIES = False
DUMP_RULES = False
PREVIEW_MAKE = False

COLORS = {"blue": "\033[1;34m", "default": "\x1B[m", "yellow": "\033[1;33m",
    "magenda": "\033[1;31m", "white": "\033[1;37m", "green": "\033[1;32m",
    "red": "\033[1;31m",
}
NOCOLORS = dict(map(lambda c: (c, ""), COLORS))

DEFAULT_COMPILER = "gcc"
DEFAULT_ARCHIVER = "ar"
DEFAULT_LINKER = "gcc"

rules = {}
phonies = set()

class cd(object):
    def __init__(self, path):
        self.path = path
    def __enter__(self):
        print "%(white)s%%s%(default)s" % COLORS % "cd %s" % self.path
        self.savedPath = os.getcwd()
        os.chdir(self.path)
    def __exit__(self, errorType, value, traceback):
        print "%(white)s%%s%(default)s" % COLORS % "cd %s" % self.savedPath
        os.chdir(self.savedPath)

def Phony(target):
    phonies.add(target)

class Rule(object):
    def __init__(self, target, prerequisites, recipe, args, kwargs):
        self.target = target
        self.prerequisites = prerequisites
        self.recipe = recipe
        self.args = args
        self.kwargs = kwargs
    def __repr__(self):
        return pprint.pformat([
            ("target", self.target in phonies and "Phony(%s)" % self.target
                or self.target),
            ("prerequisites",
                callable(self.prerequisites) and self.prerequisites.__name__
                or self.prerequisites),
            ("recipe", self.recipe.__name__),
            ("args", self.args),
            ("kwargs", self.kwargs)
        ])
    def getPrerequisites(self):
        if any(map(lambda t: type(self.prerequisites) == t, (list, type(None)))):
            prerequisites = self.prerequisites
        if type(self.prerequisites) == str:
            prerequisites = [self.prerequisites]
        elif callable(self.prerequisites):
            prerequisites = self.prerequisites(
                self.target, *self.args, **self.kwargs)
            if type(prerequisites) == str:
                prerequisites = [prerequisites]
        return prerequisites
    def runRecipe(self):
        try:
            self.recipe(self.target, *self.args, **self.kwargs)
        except ShellCommandError, e:
            if DEBUG_LOGS: print e.message
            return e.returncode
        return 0

def rule(targets, prerequisites=None, *args, **kwargs):
    assert type(targets) in [str, list], \
        "'targets' can only be a 'str' or 'list' object."
    assert type(prerequisites) in [type(None), str, list] or \
            callable(prerequisites), \
        "'prerequisites' can only be a 'None', 'str', 'list' or a callable."
    def ruleDecorator(recipe):
        for t in type(targets) == list and targets or [targets]:
            r = Rule(t, prerequisites, recipe, args, kwargs)
            rlist = rules.setdefault(r.target, [])
            rlist.append(r)
        return lambda target: None
    return ruleDecorator

def make(target): 
    shouldRunRecipe = False
    dirtyFiles = []
    if not target in rules:
        return False
    if DEBUG_LOGS or PREVIEW_MAKE: print "make(%s)" % target
    for r in rules[target]:
        prerequisites = r.getPrerequisites()
        if DEBUG_LOGS: print "prerequisites: %s" % prerequisites
        if not prerequisites:
            shouldRunRecipe = True
        else:
            for p in prerequisites:
                if make(p) or ((not target in phonies) and (
                        not os.path.exists(target) or ((not p in phonies) and
                        os.path.getmtime(target) < os.path.getmtime(p)))):
                    dirtyFiles.append(p)
                    shouldRunRecipe = True
    if SHOW_DIRTY_DEPENDENCIES:
            print "%(yellow)s%%s%(default)s" % COLORS % "%s <- %s" % (
                target, dirtyFiles)
    if shouldRunRecipe:
        for r in rules[target]:
            if PREVIEW_MAKE:
                print "%s(%s).%s()" % (r.target, prerequisites,
                    r.recipe.__name__)
                continue
            result = r.runRecipe()
            if result:
                exit(result)
        return True
    else:
        if DEBUG_LOGS: print "No need to make %s." % target
        return False

def cache(f):
    results = {}
    @wraps(f)
    def newf(*args):
        _args = map(lambda a: a or "", args)
        return results.setdefault("|".join(_args), f(*args))
    return newf

def validate(require, defaults=None):
    def validateDecorator(f):
        @wraps(f)
        def newf(**kwargs):
            missingRequiredArgs = filter(
                lambda r: not r in kwargs, require)
            if missingRequiredArgs:
                print "Error: function %s requires: %s" % (f,
                    ", ".join(missingRequiredArgs))
                return False
            if defaults:
                missingOptionalArgs = filter(
                    lambda o: (not o in kwargs) or not kwargs.get(o), defaults)
                for o in missingOptionalArgs:
                    kwargs[o] = defaults[o]
            return f(**kwargs)
        return newf
    return validateDecorator

class ShellCommandError(StandardError):
    def __init__(self, message, returncode):
        self.message = message
        self.returncode = returncode
    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__,
            self.message, self.returncode)

def runShellCommand(cmd, **kwargs):
    if type(cmd) == str:
        cmd = cmd.split()
    if kwargs.get("verbose"):
        print "%(white)s%%s%(default)s" % COLORS % " ".join(cmd)
    process = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    eof = {process.stdout: False, process.stderr: False}
    while not all(eof.values()):
        for fd in select.select(list(eof), [], [])[0]:
            line = fd.readline().strip()
            if not line:
                eof[fd] = True
                continue
            if ": warning: " in line:
                print "%(yellow)s%%s%(default)s" % COLORS % line
            elif any((s in line for s in
                    [": error: ", ": fatal error:"])):
                print "%(red)s%%s%(default)s" % COLORS % line
            else:
                print line
    process.communicate()
    if process.returncode:
        raise ShellCommandError(" ".join(cmd), process.returncode)

@validate(
    require=["compilerFlags", "source", "output"],
    defaults={
        "compiler": DEFAULT_COMPILER,
        "includePaths": [],
        "defines": [],
        "cFlags": [],
        "verbose": False,
    })
def compilee(**kwargs):
    compiler = kwargs["compiler"]
    compilerFlags = kwargs["compilerFlags"]
    outputFile = kwargs["output"]
    includePaths = kwargs["includePaths"][:]
    if not "-I." in includePaths:
        includePaths.append(".")
    includePaths = ["-I" + i for i in includePaths]
    cFlags = kwargs["cFlags"]
    defines = ["-D" + d for d in kwargs["defines"]]
    sourceFile = kwargs["source"]
    cmd = [compiler] + compilerFlags + includePaths + \
        cFlags + defines + ["-c", sourceFile] + ["-o", outputFile]
    runShellCommand(cmd, verbose=kwargs["verbose"])

@validate(
    require=["depend", "source"])
def buildDepend(**kwargs):
    kwargs["compilerFlags"] = ["-MM"]
    kwargs["output"] = kwargs["depend"]
    compilee(**kwargs)

@validate(
    require=["object", "source"])
def buildObject(**kwargs):
    kwargs["compilerFlags"] = []
    kwargs["output"] = kwargs["object"]
    kwargs["verbose"] = True
    compilee(**kwargs)

@validate(
    require=["archive", "objects"],
    defaults={
        "archiver": DEFAULT_ARCHIVER,
    })
def archive(**kwargs):
    archiver = kwargs["archiver"]
    archiveFile = kwargs["archive"]
    objectFiles = kwargs["objects"]
    cmd = [archiver, "cr", archiveFile] + objectFiles
    runShellCommand(cmd, verbose=True)

@validate(
    require=["libraries", "executable"],
    defaults={
        "linker": DEFAULT_LINKER,
        "libpaths": [],
        "libraries": [],
        "ldFlags": [],
    })
def link(**kwargs):
    linker = kwargs["linker"]
    libraryPaths = kwargs["libpaths"]
    libraries = kwargs["libraries"]
    executable = kwargs["executable"]
    ldFlags = kwargs["ldFlags"]
    cmd = [linker] + \
        ["-L%s" % p for p in libraryPaths] + \
        ["-l%s" % l for l in libraries] + \
        ldFlags + \
        ["-o", executable]
    runShellCommand(cmd, verbose=True)

# ----------------- Makefile.py -----------------

try:
    execfile("Makefile.py")
except IOError:
    print "Error: No such file: Makefile.py"
    exit(1)

# ----------------- pmake -----------------------

if __name__ == "__main__":

    # Determine if colorful output is desired
    if not ENABLE_COLOR:
        COLORS = NOCOLORS

    if DUMP_RULES:
        print "All rules are:"
        pprint.pprint(rules.values())
        print

    # Get the target
    target = "all"
    if len(sys.argv) == 2:
        target = sys.argv[1]
    
    # Make the target
    if not rules.get(target):
        print "Error: target '%s' not found" % target
        exit(1)
    make(target)
